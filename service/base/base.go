package base

import (
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"strings"

	"github.com/deta/deta-go/deta"
	"github.com/deta/deta-go/internal/client"
)

const (
	baseEndpoint = "https://database.deta.sh/v1"
)

// Base is a Deta Base service client that offers the API to make requests to Deta Base
type Base struct {
	// deta api client
	client *client.DetaClient

	// base utilities
	Util *util
}

// Items always stored as a map of string to interface{}
type baseItem map[string]interface{}

// Query is a datatype to provide a query to a Fetch operation.
//
// Items in the query are ORed.
//		q := Query{
//			{"active": true},
//			{"age?lt": 32},
//		}
// The example above fetches items where 'active' is true OR 'age' is less than 32.
type Query []map[string]interface{}

// Updates is a datatype to provide updates to an item in an Update operation
type Updates map[string]interface{}

// New returns a pointer to a new Base
func New(d *deta.Deta, baseName string) (*Base, error) {
	if d == nil {
		return nil, deta.ErrEmptyDetaInstance
	}
	if baseName == "" {
		return nil, deta.ErrBadBaseName
	}
	projectKey := d.ProjectKey
	parts := strings.Split(projectKey, "_")
	projectID := parts[0]

	rootEndpoint := os.Getenv("DETA_BASE_ROOT_ENDPOINT")
	if rootEndpoint == "" {
		rootEndpoint = baseEndpoint
	}
	rootEndpoint = fmt.Sprintf("%s/%s/%s", rootEndpoint, projectID, baseName)

	return &Base{
		client: client.NewDetaClient(rootEndpoint, &client.AuthInfo{
			AuthType:    "api-key",
			HeaderKey:   "X-API-Key",
			HeaderValue: projectKey,
		}),
	}, nil
}

func (b *Base) removeEmptyKey(bi baseItem) error {
	key, ok := bi["key"]
	if !ok {
		return nil
	}
	switch key.(type) {
	case string:
		if key == "" {
			delete(bi, "key")
		}
		return nil
	default:
		return fmt.Errorf("%w: %v", deta.ErrBadItem, "Key is not a string")
	}
}

func (b *Base) modifyItem(item interface{}) (baseItem, error) {
	data, err := json.Marshal(item)
	if err != nil {
		return nil, deta.ErrBadItem
	}
	var bi baseItem
	err = json.Unmarshal(data, &bi)
	if err != nil {
		return nil, fmt.Errorf("%w: %s", deta.ErrBadItem, err)
	}
	err = b.removeEmptyKey(bi)
	if err != nil {
		return nil, err
	}
	return bi, nil
}

// modifies items to a []baseItem
func (b *Base) modifyItems(items interface{}) ([]baseItem, error) {
	data, err := json.Marshal(items)
	if err != nil {
		return nil, deta.ErrBadItem
	}
	var bi []baseItem
	err = json.Unmarshal(data, &bi)
	if err != nil {
		return nil, fmt.Errorf("%w: %s", deta.ErrBadItem, err)
	}
	for _, item := range bi {
		err = b.removeEmptyKey(item)
		if err != nil {
			return nil, err
		}
	}
	return bi, nil
}

type putResponse struct {
	Processed map[string][]baseItem `json:"processed"`
	Failed    map[string][]baseItem `json:"failed"`
}

func (b *Base) put(items []baseItem) ([]string, error) {
	body := map[string]interface{}{
		"items": items,
	}
	o, err := b.client.Request(&client.RequestInput{
		Path:   "/items",
		Method: "PUT",
		Body:   body,
	})
	if err != nil {
		return nil, err
	}

	var pr putResponse
	err = json.Unmarshal(o.Body, &pr)
	if err != nil {
		return nil, err
	}

	var keys []string
	for _, item := range pr.Processed["items"] {
		keys = append(keys, item["key"].(string))
	}

	return keys, nil
}

// Put an item in the database.
//
// If the item is a struct, denote the key of the item with a json struct tag "key".
// If the item is a map, provide the key of the item in the map under "key".
// If an item with the same key already exists in the database, the existing item is overwritten.
// If the 'key' is provided in the item, a key is autogenerated.
// Returns the key of the item that was put in the database.
func (b *Base) Put(item interface{}) (string, error) {
	if item == nil {
		return "", nil
	}

	items := []interface{}{item}
	modifiedItems, err := b.modifyItems(items)
	if err != nil {
		return "", err
	}

	putKeys, err := b.put(modifiedItems)
	if err != nil {
		return "", err
	}
	return putKeys[0], nil
}

// PutMany puts multiple items in the database.
//
// Puts at most 25 items in a single request.
// The items should be a slice.
// Each item in the slice is treated similarly as the input to the Put operation.
// Returns the slice of keys of the items put in the database.
func (b *Base) PutMany(items interface{}) ([]string, error) {
	modifiedItems, err := b.modifyItems(items)
	if err != nil {
		return nil, err
	}

	if len(modifiedItems) == 0 {
		return nil, nil
	}
	if len(modifiedItems) > 25 {
		return nil, deta.ErrTooManyItems
	}
	return b.put(modifiedItems)
}

// Get an item from the database.
//
// The item is scanned onto `dest`.
func (b *Base) Get(key string, dest interface{}) error {
	escapedKey := url.PathEscape(key)
	o, err := b.client.Request(&client.RequestInput{
		Path:   fmt.Sprintf("/items/%s", escapedKey),
		Method: "GET",
	})
	if err != nil {
		return err
	}
	err = json.Unmarshal(o.Body, &dest)
	if err != nil {
		return fmt.Errorf("%w: %v", deta.ErrBadDestination, err)
	}
	return nil
}

type insertRequest struct {
	Item baseItem `json:"item"`
}

// Insert an item in the database only if an item with the same key does not exist.
//
// The item is treated similarly as the input to the Put operation.
// Returns the key of the item inserted in the database.
func (b *Base) Insert(item interface{}) (string, error) {
	modifiedItem, err := b.modifyItem(item)
	if err != nil {
		return "", err
	}

	ir := &insertRequest{
		Item: modifiedItem,
	}

	o, err := b.client.Request(&client.RequestInput{
		Path:   "/items",
		Method: "POST",
		Body:   ir,
	})

	if err != nil {
		return "", err
	}

	var bi baseItem
	err = json.Unmarshal(o.Body, &bi)
	if err != nil {
		return "", err
	}
	return bi["key"].(string), nil
}

type updateRequest struct {
	Set       map[string]interface{} `json:"set"`
	Trim      []string               `json:"delete"`
	Append    map[string]interface{} `json:"append"`
	Prepend   map[string]interface{} `json:"prepend"`
	Increment map[string]interface{} `json:"increment"`
}

// converts updates to an update request
func (b *Base) updatesToUpdateRequest(updates Updates) *updateRequest {
	updateReq := &updateRequest{
		Set:       make(map[string]interface{}),
		Append:    make(map[string]interface{}),
		Prepend:   make(map[string]interface{}),
		Increment: make(map[string]interface{}),
		Trim:      make([]string, 0),
	}
	for k, v := range updates {
		switch val := v.(type) {
		case *trimUtil:
			updateReq.Trim = append(updateReq.Trim, k)
		case *appendUtil:
			updateReq.Append[k] = val.value
		case *prependUtil:
			updateReq.Prepend[k] = val.value
		case *incrementUtil:
			updateReq.Increment[k] = val.value
		default:
			updateReq.Set[k] = v
		}
	}
	return updateReq
}

// Update an existing item in the database.
//
// Updates according to the the provided 'updates'.
func (b *Base) Update(key string, updates Updates) error {
	// escape key
	escapedKey := url.PathEscape(key)

	ur := b.updatesToUpdateRequest(updates)
	_, err := b.client.Request(&client.RequestInput{
		Path:   fmt.Sprintf("/items/%s", escapedKey),
		Method: "PATCH",
		Body:   ur,
	})
	if err != nil {
		return err
	}
	return nil
}

// Delete an item from the database.
//
// If the key does not exist, a nil error is returned.
func (b *Base) Delete(key string) error {
	// escape the key
	escapedKey := url.PathEscape(key)

	_, err := b.client.Request(&client.RequestInput{
		Path:   fmt.Sprintf("/items/%s", escapedKey),
		Method: "DELETE",
	})
	if err != nil {
		return err
	}
	return nil
}

type paging struct {
	Size int     `json:"size"`
	Last *string `json:"last"`
}

type fetchRequest struct {
	Query Query   `json:"query"`
	Last  *string `json:"last,omitempty"`
	Limit *int    `json:"limit,omitempty"`
}

type fetchResponse struct {
	Paging *paging       `json:"paging"`
	Items  []interface{} `json:"items"`
}

func (b *Base) fetch(req *fetchRequest) (*fetchResponse, error) {
	o, err := b.client.Request(&client.RequestInput{
		Path:   "/query",
		Method: "POST",
		Body:   req,
	})
	if err != nil {
		return nil, err
	}
	var fr fetchResponse
	err = json.Unmarshal(o.Body, &fr)
	if err != nil {
		return nil, err
	}
	return &fr, nil
}

// FetchInput input to Fetch operation
type FetchInput struct {
	// filters to apply to items
	// A nil value applies no queries and fetches all items
	Q Query
	// the destination to store the results
	Dest interface{}
	// the maximum number of items to fetch
	// value of 0 or less applies no limit
	Limit int
	// the last key evaluated in a paginated response
	// leave empty if not a subsequent fetch request
	LastKey string
}

// Fetch items from the database.
//
// Fetch is paginated, returns the last key fetched if further pages are left.
// Provide the last key in the subsequent fetch operation to fetch remaining pages.
func (b *Base) Fetch(i *FetchInput) (string, error) {
	req := &fetchRequest{
		Query: i.Q,
	}
	if i.Limit > 0 {
		req.Limit = &i.Limit
	}

	if i.LastKey != "" {
		req.Last = &i.LastKey
	}

	res, err := b.fetch(req)
	if err != nil {
		return "", err
	}

	data, err := json.Marshal(res.Items)
	if err != nil {
		return "", err
	}
	err = json.Unmarshal(data, &i.Dest)
	if err != nil {
		return "", fmt.Errorf("%w: %v", deta.ErrBadDestination, err)
	}

	lastKey := ""
	if res.Paging.Last != nil {
		lastKey = *res.Paging.Last
	}
	return lastKey, nil
}
